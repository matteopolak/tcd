// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str = include_str!(
	"C:\\Users\\m\\Documents\\Projects\\matteopolak\\twitch-rs\\prisma\\schema.prisma"
);
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod comment_fragment {
	use super::_prisma::*;
	use super::*;
	pub mod index {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::IndexEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Index(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Index(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementIndex(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementIndex(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyIndex(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideIndex(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIndex(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Index(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("index").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Index(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("index").build()
			}
		}
	}
	pub mod comment_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::CommentIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::CommentId(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::CommentId(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCommentId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CommentId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("commentId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CommentId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("commentId").build()
			}
		}
	}
	pub mod comment {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentIs(value)
		}
		pub fn is_not(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentIsNot(value)
		}
		pub struct Fetch(pub comment::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<comment::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Comment(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(comment::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: comment::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(comment::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectComment(value.0)
			}
		}
		pub enum Include {
			Select(Vec<comment::SelectParam>),
			Include(Vec<comment::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Comment(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comment");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<comment::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<comment::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<comment::SelectParam>),
			Include(Vec<comment::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Comment(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comment");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<comment::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<comment::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod text {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TextEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Text(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Text(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetText(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Text(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("text").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Text(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("text").build()
			}
		}
	}
	pub mod emote {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::EmoteEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Emote(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Emote(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub Option<String>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetEmote(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Emote(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("emote").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Emote(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("emote").build()
			}
		}
	}
	pub fn index_comment_id<T: From<UniqueWhereParam>>(index: i32, comment_id: String) -> T {
		UniqueWhereParam::IndexCommentIdEquals(index, comment_id).into()
	}
	pub fn create(
		index: i32,
		comment: super::comment::UniqueWhereParam,
		text: String,
		_params: Vec<SetParam>,
	) -> (i32, super::comment::UniqueWhereParam, String, Vec<SetParam>) {
		(index, comment, text, _params)
	}
	pub fn create_unchecked(
		index: i32,
		comment_id: String,
		text: String,
		_params: Vec<SetParam>,
	) -> (i32, String, String, Vec<SetParam>) {
		(index, comment_id, text, _params)
	}
	#[macro_export]
	macro_rules ! _select_comment_fragment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: comment_fragment :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: comment_fragment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: comment_fragment :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: comment_fragment :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: comment_fragment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: comment_fragment :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { index , comment_id , comment , text , emote } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: comment_fragment :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: comment_fragment :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: comment_fragment :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: comment_fragment :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["index" , "commentId" , "comment" , "text" , "emote"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: comment_fragment :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; index) => { i32 } ; (@ field_type ; comment_id) => { String } ; (@ field_type ; comment : $ selection_mode : ident { $ ($ selections : tt) + }) => { comment :: Data } ; (@ field_type ; comment) => { crate :: prisma :: comment :: Data } ; (@ field_type ; text) => { String } ; (@ field_type ; emote) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "CommentFragment" , available fields are "index, comment_id, comment, text, emote")) } ; (@ field_module ; comment : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; index) => { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: index :: Select) } ; (@ selection_field_to_selection_param ; comment_id) => { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: comment_id :: Select) } ; (@ selection_field_to_selection_param ; comment $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: comment :: Select :: $ selection_mode ($ crate :: prisma :: comment :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comment $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: comment :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; text) => { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: text :: Select) } ; (@ selection_field_to_selection_param ; emote) => { Into :: < $ crate :: prisma :: comment_fragment :: SelectParam > :: into ($ crate :: prisma :: comment_fragment :: emote :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: comment_fragment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; index) => { "index" } ; (@ field_serde_name ; comment_id) => { "commentId" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; emote) => { "emote" } ; }
	pub use _select_comment_fragment as select;
	pub enum SelectParam {
		Index(index::Select),
		CommentId(comment_id::Select),
		Comment(comment::Select),
		Text(text::Select),
		Emote(emote::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Index(data) => data.to_selection(),
				Self::CommentId(data) => data.to_selection(),
				Self::Comment(data) => data.to_selection(),
				Self::Text(data) => data.to_selection(),
				Self::Emote(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_comment_fragment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: comment_fragment :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: comment_fragment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: comment_fragment :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: comment_fragment :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: comment_fragment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: comment_fragment :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { comment } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub index : i32 , pub comment_id : String , pub text : String , pub emote : Option < String > , $ (pub $ field : $ crate :: prisma :: comment_fragment :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (index) , stringify ! (comment_id) , stringify ! (text) , stringify ! (emote)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; index) , & self . index) ? ; state . serialize_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; comment_id) , & self . comment_id) ? ; state . serialize_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; text) , & self . text) ? ; state . serialize_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; emote) , & self . emote) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , index , comment_id , text , emote } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; index) , ", " , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; comment_id) , ", " , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; text) , ", " , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; emote) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; index) => Ok (Field :: index) , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; comment_id) => Ok (Field :: comment_id) , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; text) => Ok (Field :: text) , $ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; emote) => Ok (Field :: emote) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut index = None ; let mut comment_id = None ; let mut text = None ; let mut emote = None ; while let Some (key) = map . next_key () ? { match key { Field :: index => { if index . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; index))) ; } index = Some (map . next_value () ?) ; } Field :: comment_id => { if comment_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; comment_id))) ; } comment_id = Some (map . next_value () ?) ; } Field :: text => { if text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; text))) ; } text = Some (map . next_value () ?) ; } Field :: emote => { if emote . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; emote))) ; } emote = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; $ field))) ? ;) * let index = index . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; index))) ? ; let comment_id = comment_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; comment_id))) ? ; let text = text . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; text))) ? ; let emote = emote . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment_fragment :: include ! (@ field_serde_name ; emote))) ? ; Ok (Data { index , comment_id , text , emote , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["index" , "commentId" , "comment" , "text" , "emote"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: comment_fragment :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; comment : $ selection_mode : ident { $ ($ selections : tt) + }) => { comment :: Data } ; (@ field_type ; comment) => { crate :: prisma :: comment :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "CommentFragment" , available relations are "comment")) } ; (@ field_module ; comment : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; comment $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment_fragment :: IncludeParam > :: into ($ crate :: prisma :: comment_fragment :: comment :: Include :: $ selection_mode ($ crate :: prisma :: comment :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comment $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment_fragment :: IncludeParam > :: into ($ crate :: prisma :: comment_fragment :: comment :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: comment_fragment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; index) => { "index" } ; (@ field_serde_name ; comment_id) => { "commentId" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; emote) => { "emote" } ; }
	pub use _include_comment_fragment as include;
	pub enum IncludeParam {
		Index(index::Include),
		CommentId(comment_id::Include),
		Comment(comment::Include),
		Text(text::Include),
		Emote(emote::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Index(data) => data.to_selection(),
				Self::CommentId(data) => data.to_selection(),
				Self::Comment(data) => data.to_selection(),
				Self::Text(data) => data.to_selection(),
				Self::Emote(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "index")]
		pub index: i32,
		#[serde(rename = "commentId")]
		pub comment_id: String,
		#[serde(rename = "comment")]
		pub comment: Option<Box<super::comment::Data>>,
		#[serde(rename = "text")]
		pub text: String,
		#[serde(rename = "emote")]
		pub emote: Option<String>,
	}
	impl Data {
		pub fn comment(
			&self,
		) -> Result<&super::comment::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.comment
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(comment),
				))
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Comment(super::comment::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Comment(args) => {
					let mut selections = < super :: comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("comment");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetIndex(i32),
		IncrementIndex(i32),
		DecrementIndex(i32),
		MultiplyIndex(i32),
		DivideIndex(i32),
		SetCommentId(String),
		ConnectComment(super::comment::UniqueWhereParam),
		SetText(String),
		SetEmote(Option<String>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetIndex(value) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementIndex(value) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementIndex(value) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyIndex(value) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideIndex(value) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetCommentId(value) => (
					"commentId".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectComment(where_param) => (
					"comment".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetText(value) => (
					"text".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetEmote(value) => (
					"emote".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Index(::prisma_client_rust::Direction),
		CommentId(::prisma_client_rust::Direction),
		Text(::prisma_client_rust::Direction),
		Emote(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Index(direction) => (
					"index".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::CommentId(direction) => (
					"commentId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Text(direction) => (
					"text".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Emote(direction) => (
					"emote".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IndexCommentIdEquals(i32, String),
		IndexEquals(i32),
		Index(_prisma::read_filters::IntFilter),
		CommentIdEquals(String),
		CommentId(_prisma::read_filters::StringFilter),
		CommentIs(Vec<super::comment::WhereParam>),
		CommentIsNot(Vec<super::comment::WhereParam>),
		TextEquals(String),
		Text(_prisma::read_filters::StringFilter),
		EmoteEquals(Option<String>),
		Emote(_prisma::read_filters::StringFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IndexCommentIdEquals(index, comment_id) => (
					"index_commentId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							"index".to_string(),
							::prisma_client_rust::PrismaValue::Int(index as i64),
						),
						(
							"commentId".to_string(),
							::prisma_client_rust::PrismaValue::String(comment_id),
						),
					]),
				),
				Self::IndexEquals(value) => (
					"index",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Index(value) => ("index", value.into()),
				Self::CommentIdEquals(value) => (
					"commentId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::CommentId(value) => ("commentId", value.into()),
				Self::CommentIs(where_params) => (
					"comment",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentIsNot(where_params) => (
					"comment",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TextEquals(value) => (
					"text",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Text(value) => ("text", value.into()),
				Self::EmoteEquals(value) => (
					"emote",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::Emote(value) => ("emote", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IndexCommentIdEquals(i32, String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IndexCommentIdEquals(index, comment_id) => {
					Self::IndexCommentIdEquals(index, comment_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "CommentFragment";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["index", "commentId", "text", "emote"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			index: i32,
			comment: super::comment::UniqueWhereParam,
			text: String,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(index::set(index));
			_params.push(comment::connect(comment));
			_params.push(text::set(text));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(i32, String, String, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(index, comment_id, text, mut _params)| {
					_params.push(index::set(index));
					_params.push(comment_id::set(comment_id));
					_params.push(text::set(text));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(index, comment, text, mut _params): (
				i32,
				super::comment::UniqueWhereParam,
				String,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(index::set(index));
			_params.push(comment::connect(comment));
			_params.push(text::set(text));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod comment {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod user_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::UserIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::UserId(direction)
		}
		pub fn in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
		}
		pub fn lt(value: i64) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
		}
		pub fn lte(value: i64) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
		}
		pub fn gt(value: i64) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
		}
		pub fn gte(value: i64) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
		}
		pub fn not(value: i64) -> WhereParam {
			WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
		}
		pub fn increment(value: i64) -> SetParam {
			SetParam::IncrementUserId(value)
		}
		pub fn decrement(value: i64) -> SetParam {
			SetParam::DecrementUserId(value)
		}
		pub fn multiply(value: i64) -> SetParam {
			SetParam::MultiplyUserId(value)
		}
		pub fn divide(value: i64) -> SetParam {
			SetParam::DivideUserId(value)
		}
		pub struct Set(pub i64);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUserId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::UserId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("userId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::UserId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("userId").build()
			}
		}
	}
	pub mod user {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
			WhereParam::UserIs(value)
		}
		pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
			WhereParam::UserIsNot(value)
		}
		pub struct Fetch(pub user::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::User(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(user::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(user::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectUser(value.0)
			}
		}
		pub enum Include {
			Select(Vec<user::SelectParam>),
			Include(Vec<user::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::User(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("user");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<user::SelectParam>),
			Include(Vec<user::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::User(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("user");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod video_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::VideoIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::VideoId(direction)
		}
		pub fn in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::NotInVec(value))
		}
		pub fn lt(value: i64) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::Lt(value))
		}
		pub fn lte(value: i64) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::Lte(value))
		}
		pub fn gt(value: i64) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::Gt(value))
		}
		pub fn gte(value: i64) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::Gte(value))
		}
		pub fn not(value: i64) -> WhereParam {
			WhereParam::VideoId(_prisma::read_filters::BigIntFilter::Not(value))
		}
		pub fn increment(value: i64) -> SetParam {
			SetParam::IncrementVideoId(value)
		}
		pub fn decrement(value: i64) -> SetParam {
			SetParam::DecrementVideoId(value)
		}
		pub fn multiply(value: i64) -> SetParam {
			SetParam::MultiplyVideoId(value)
		}
		pub fn divide(value: i64) -> SetParam {
			SetParam::DivideVideoId(value)
		}
		pub struct Set(pub i64);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetVideoId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::VideoId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("videoId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::VideoId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("videoId").build()
			}
		}
	}
	pub mod video {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<video::WhereParam>) -> WhereParam {
			WhereParam::VideoIs(value)
		}
		pub fn is_not(value: Vec<video::WhereParam>) -> WhereParam {
			WhereParam::VideoIsNot(value)
		}
		pub struct Fetch(pub video::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<video::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Video(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(video::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: video::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(video::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectVideo(value.0)
			}
		}
		pub enum Include {
			Select(Vec<video::SelectParam>),
			Include(Vec<video::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Video(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("video");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<video::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<video::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<video::SelectParam>),
			Include(Vec<video::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Video(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("video");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<video::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<video::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod fragments {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<comment_fragment::WhereParam>) -> WhereParam {
			WhereParam::FragmentsSome(value)
		}
		pub fn every(value: Vec<comment_fragment::WhereParam>) -> WhereParam {
			WhereParam::FragmentsEvery(value)
		}
		pub fn none(value: Vec<comment_fragment::WhereParam>) -> WhereParam {
			WhereParam::FragmentsNone(value)
		}
		pub struct Fetch(pub comment_fragment::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<comment_fragment::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: comment_fragment::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: comment_fragment::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Fragments(fetch.0)
			}
		}
		pub fn fetch(params: Vec<comment_fragment::WhereParam>) -> Fetch {
			Fetch(comment_fragment::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<comment_fragment::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<comment_fragment::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFragments(params)
		}
		pub fn set(params: Vec<comment_fragment::UniqueWhereParam>) -> SetParam {
			SetParam::SetFragments(params)
		}
		pub struct Connect(pub Vec<comment_fragment::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectFragments(value.0)
			}
		}
		pub enum Include {
			Select(
				comment_fragment::ManyArgs,
				Vec<comment_fragment::SelectParam>,
			),
			Include(
				comment_fragment::ManyArgs,
				Vec<comment_fragment::IncludeParam>,
			),
			Fetch(comment_fragment::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Fragments(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("fragments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment_fragment::ManyArgs,
				nested_selections: Vec<comment_fragment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment_fragment::ManyArgs,
				nested_selections: Vec<comment_fragment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(
				comment_fragment::ManyArgs,
				Vec<comment_fragment::SelectParam>,
			),
			Include(
				comment_fragment::ManyArgs,
				Vec<comment_fragment::IncludeParam>,
			),
			Fetch(comment_fragment::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Fragments(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("fragments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment_fragment::ManyArgs,
				nested_selections: Vec<comment_fragment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment_fragment::ManyArgs,
				nested_selections: Vec<comment_fragment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod created_at {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAtEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::CreatedAt(direction)
		}
		pub fn in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
		}
		pub fn not_in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
		}
		pub fn lt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
		}
		pub fn lte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
		}
		pub fn gt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
		}
		pub fn gte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
		}
		pub fn not(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCreatedAt(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CreatedAt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CreatedAt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
	}
	pub fn create(
		id: String,
		user: super::user::UniqueWhereParam,
		video: super::video::UniqueWhereParam,
		created_at: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> (
		String,
		super::user::UniqueWhereParam,
		super::video::UniqueWhereParam,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		Vec<SetParam>,
	) {
		(id, user, video, created_at, _params)
	}
	pub fn create_unchecked(
		id: String,
		user_id: i64,
		video_id: i64,
		created_at: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> (
		String,
		i64,
		i64,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		Vec<SetParam>,
	) {
		(id, user_id, video_id, created_at, _params)
	}
	#[macro_export]
	macro_rules ! _select_comment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: comment :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: comment :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: comment :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: comment :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_id , user , video_id , video , fragments , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: comment :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: comment :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: comment :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: comment :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "userId" , "user" , "videoId" , "video" , "fragments" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: comment :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { user :: Data } ; (@ field_type ; user) => { crate :: prisma :: user :: Data } ; (@ field_type ; video_id) => { i64 } ; (@ field_type ; video : $ selection_mode : ident { $ ($ selections : tt) + }) => { video :: Data } ; (@ field_type ; video) => { crate :: prisma :: video :: Data } ; (@ field_type ; fragments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < fragments :: Data > } ; (@ field_type ; fragments) => { Vec < crate :: prisma :: comment_fragment :: Data > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Comment" , available fields are "id, user_id, user, video_id, video, fragments, created_at")) } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; video : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: video :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; fragments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment_fragment :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: user_id :: Select) } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: user :: Select :: $ selection_mode ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: user :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; video_id) => { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: video_id :: Select) } ; (@ selection_field_to_selection_param ; video $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: video :: Select :: $ selection_mode ($ crate :: prisma :: video :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; video $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: video :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; fragments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: fragments :: Select :: $ selection_mode ($ crate :: prisma :: comment_fragment :: ManyArgs :: new ($ crate :: prisma :: comment_fragment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment_fragment :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; fragments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: fragments :: Select :: Fetch ($ crate :: prisma :: comment_fragment :: ManyArgs :: new ($ crate :: prisma :: comment_fragment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: comment :: SelectParam > :: into ($ crate :: prisma :: comment :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: comment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "userId" } ; (@ field_serde_name ; user) => { "user" } ; (@ field_serde_name ; video_id) => { "videoId" } ; (@ field_serde_name ; video) => { "video" } ; (@ field_serde_name ; fragments) => { "fragments" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _select_comment as select;
	pub enum SelectParam {
		Id(id::Select),
		UserId(user_id::Select),
		User(user::Select),
		VideoId(video_id::Select),
		Video(video::Select),
		Fragments(fragments::Select),
		CreatedAt(created_at::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::UserId(data) => data.to_selection(),
				Self::User(data) => data.to_selection(),
				Self::VideoId(data) => data.to_selection(),
				Self::Video(data) => data.to_selection(),
				Self::Fragments(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_comment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: comment :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: comment :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: comment :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: comment :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user , video , fragments } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub user_id : i64 , pub video_id : i64 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: comment :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (video_id) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; video_id) , & self . video_id) ? ; state . serialize_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_id , video_id , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; video_id) , ", " , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; video_id) => Ok (Field :: video_id) , $ crate :: prisma :: comment :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_id = None ; let mut video_id = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: video_id => { if video_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; video_id))) ; } video_id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; user_id))) ? ; let video_id = video_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; video_id))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: comment :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { id , user_id , video_id , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "userId" , "user" , "videoId" , "video" , "fragments" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: comment :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { user :: Data } ; (@ field_type ; user) => { crate :: prisma :: user :: Data } ; (@ field_type ; video : $ selection_mode : ident { $ ($ selections : tt) + }) => { video :: Data } ; (@ field_type ; video) => { crate :: prisma :: video :: Data } ; (@ field_type ; fragments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < fragments :: Data > } ; (@ field_type ; fragments) => { Vec < crate :: prisma :: comment_fragment :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Comment" , available relations are "user, video, fragments")) } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; video : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: video :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; fragments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment_fragment :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: user :: Include :: $ selection_mode ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: user :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; video $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: video :: Include :: $ selection_mode ($ crate :: prisma :: video :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; video $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: video :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; fragments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: fragments :: Include :: $ selection_mode ($ crate :: prisma :: comment_fragment :: ManyArgs :: new ($ crate :: prisma :: comment_fragment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment_fragment :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; fragments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: comment :: IncludeParam > :: into ($ crate :: prisma :: comment :: fragments :: Include :: Fetch ($ crate :: prisma :: comment_fragment :: ManyArgs :: new ($ crate :: prisma :: comment_fragment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: comment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "userId" } ; (@ field_serde_name ; user) => { "user" } ; (@ field_serde_name ; video_id) => { "videoId" } ; (@ field_serde_name ; video) => { "video" } ; (@ field_serde_name ; fragments) => { "fragments" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _include_comment as include;
	pub enum IncludeParam {
		Id(id::Include),
		UserId(user_id::Include),
		User(user::Include),
		VideoId(video_id::Include),
		Video(video::Include),
		Fragments(fragments::Include),
		CreatedAt(created_at::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::UserId(data) => data.to_selection(),
				Self::User(data) => data.to_selection(),
				Self::VideoId(data) => data.to_selection(),
				Self::Video(data) => data.to_selection(),
				Self::Fragments(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: String,
		#[serde(rename = "userId")]
		pub user_id: i64,
		#[serde(rename = "user")]
		pub user: Option<Box<super::user::Data>>,
		#[serde(rename = "videoId")]
		pub video_id: i64,
		#[serde(rename = "video")]
		pub video: Option<Box<super::video::Data>>,
		#[serde(rename = "fragments")]
		pub fragments: Option<Vec<super::comment_fragment::Data>>,
		#[serde(rename = "createdAt")]
		pub created_at:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
	}
	impl Data {
		pub fn user(
			&self,
		) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.user
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(user),
				))
				.map(|v| v.as_ref())
		}
		pub fn video(
			&self,
		) -> Result<&super::video::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.video
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(video),
				))
				.map(|v| v.as_ref())
		}
		pub fn fragments(
			&self,
		) -> Result<
			&Vec<super::comment_fragment::Data>,
			::prisma_client_rust::RelationNotFetchedError,
		> {
			self.fragments
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(fragments),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		User(super::user::UniqueArgs),
		Video(super::video::UniqueArgs),
		Fragments(super::comment_fragment::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::User(args) => {
					let mut selections = < super :: user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("user");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Video(args) => {
					let mut selections = < super :: video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("video");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Fragments(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: comment_fragment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("fragments");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(String),
		SetUserId(i64),
		IncrementUserId(i64),
		DecrementUserId(i64),
		MultiplyUserId(i64),
		DivideUserId(i64),
		ConnectUser(super::user::UniqueWhereParam),
		SetVideoId(i64),
		IncrementVideoId(i64),
		DecrementVideoId(i64),
		MultiplyVideoId(i64),
		DivideVideoId(i64),
		ConnectVideo(super::video::UniqueWhereParam),
		ConnectFragments(Vec<super::comment_fragment::UniqueWhereParam>),
		DisconnectFragments(Vec<super::comment_fragment::UniqueWhereParam>),
		SetFragments(Vec<super::comment_fragment::UniqueWhereParam>),
		SetCreatedAt(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetUserId(value) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				),
				SetParam::IncrementUserId(value) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DecrementUserId(value) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::MultiplyUserId(value) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DivideUserId(value) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::ConnectUser(where_param) => (
					"user".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::user::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetVideoId(value) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				),
				SetParam::IncrementVideoId(value) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DecrementVideoId(value) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::MultiplyVideoId(value) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DivideVideoId(value) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::ConnectVideo(where_param) => (
					"video".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::video::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::ConnectFragments(where_params) => (
					"fragments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment_fragment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectFragments(where_params) => (
					"fragments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment_fragment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetFragments(where_params) => (
					"fragments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment_fragment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetCreatedAt(value) => (
					"createdAt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		UserId(::prisma_client_rust::Direction),
		VideoId(::prisma_client_rust::Direction),
		CreatedAt(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::UserId(direction) => (
					"userId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::VideoId(direction) => (
					"videoId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::CreatedAt(direction) => (
					"createdAt".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(String),
		Id(_prisma::read_filters::StringFilter),
		UserIdEquals(i64),
		UserId(_prisma::read_filters::BigIntFilter),
		UserIs(Vec<super::user::WhereParam>),
		UserIsNot(Vec<super::user::WhereParam>),
		VideoIdEquals(i64),
		VideoId(_prisma::read_filters::BigIntFilter),
		VideoIs(Vec<super::video::WhereParam>),
		VideoIsNot(Vec<super::video::WhereParam>),
		FragmentsSome(Vec<super::comment_fragment::WhereParam>),
		FragmentsEvery(Vec<super::comment_fragment::WhereParam>),
		FragmentsNone(Vec<super::comment_fragment::WhereParam>),
		CreatedAtEquals(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
		CreatedAt(_prisma::read_filters::DateTimeFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::UserIdEquals(value) => (
					"userId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				Self::UserId(value) => ("userId", value.into()),
				Self::UserIs(where_params) => (
					"user",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::UserIsNot(where_params) => (
					"user",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::VideoIdEquals(value) => (
					"videoId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				Self::VideoId(value) => ("videoId", value.into()),
				Self::VideoIs(where_params) => (
					"video",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::VideoIsNot(where_params) => (
					"video",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FragmentsSome(where_params) => (
					"fragments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FragmentsEvery(where_params) => (
					"fragments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FragmentsNone(where_params) => (
					"fragments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CreatedAtEquals(value) => (
					"createdAt",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				),
				Self::CreatedAt(value) => ("createdAt", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Comment";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "userId", "videoId", "createdAt"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			id: String,
			user: super::user::UniqueWhereParam,
			video: super::video::UniqueWhereParam,
			created_at: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(id::set(id));
			_params.push(user::connect(user));
			_params.push(video::connect(video));
			_params.push(created_at::set(created_at));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(
				String,
				i64,
				i64,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				Vec<SetParam>,
			)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(id, user_id, video_id, created_at, mut _params)| {
					_params.push(id::set(id));
					_params.push(user_id::set(user_id));
					_params.push(video_id::set(video_id));
					_params.push(created_at::set(created_at));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(id, user, video, created_at, mut _params): (
				String,
				super::user::UniqueWhereParam,
				super::video::UniqueWhereParam,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(id::set(id));
			_params.push(user::connect(user));
			_params.push(video::connect(video));
			_params.push(created_at::set(created_at));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod video {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::NotInVec(value))
		}
		pub fn lt(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Lt(value))
		}
		pub fn lte(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Lte(value))
		}
		pub fn gt(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Gt(value))
		}
		pub fn gte(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Gte(value))
		}
		pub fn not(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Not(value))
		}
		pub fn increment(value: i64) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i64) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i64) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i64) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i64);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod author_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::AuthorIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::AuthorId(direction)
		}
		pub fn in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::NotInVec(value))
		}
		pub fn lt(value: i64) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Lt(value))
		}
		pub fn lte(value: i64) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Lte(value))
		}
		pub fn gt(value: i64) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Gt(value))
		}
		pub fn gte(value: i64) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Gte(value))
		}
		pub fn not(value: i64) -> WhereParam {
			WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Not(value))
		}
		pub fn increment(value: i64) -> SetParam {
			SetParam::IncrementAuthorId(value)
		}
		pub fn decrement(value: i64) -> SetParam {
			SetParam::DecrementAuthorId(value)
		}
		pub fn multiply(value: i64) -> SetParam {
			SetParam::MultiplyAuthorId(value)
		}
		pub fn divide(value: i64) -> SetParam {
			SetParam::DivideAuthorId(value)
		}
		pub struct Set(pub i64);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetAuthorId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::AuthorId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("authorId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::AuthorId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("authorId").build()
			}
		}
	}
	pub mod author {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
			WhereParam::AuthorIs(value)
		}
		pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
			WhereParam::AuthorIsNot(value)
		}
		pub struct Fetch(pub user::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Author(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(user::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(user::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectAuthor(value.0)
			}
		}
		pub enum Include {
			Select(Vec<user::SelectParam>),
			Include(Vec<user::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Author(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("author");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<user::SelectParam>),
			Include(Vec<user::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Author(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("author");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod comments {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsSome(value)
		}
		pub fn every(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsEvery(value)
		}
		pub fn none(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsNone(value)
		}
		pub struct Fetch(pub comment::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<comment::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: comment::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: comment::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Comments(fetch.0)
			}
		}
		pub fn fetch(params: Vec<comment::WhereParam>) -> Fetch {
			Fetch(comment::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<comment::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectComments(params)
		}
		pub fn set(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::SetComments(params)
		}
		pub struct Connect(pub Vec<comment::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectComments(value.0)
			}
		}
		pub enum Include {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Comments(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Comments(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod created_at {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAtEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::CreatedAt(direction)
		}
		pub fn in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
		}
		pub fn not_in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
		}
		pub fn lt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
		}
		pub fn lte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
		}
		pub fn gt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
		}
		pub fn gte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
		}
		pub fn not(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCreatedAt(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CreatedAt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CreatedAt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
	}
	pub fn create(
		id: i64,
		author: super::user::UniqueWhereParam,
		created_at: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> (
		i64,
		super::user::UniqueWhereParam,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		Vec<SetParam>,
	) {
		(id, author, created_at, _params)
	}
	pub fn create_unchecked(
		id: i64,
		author_id: i64,
		created_at: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> (
		i64,
		i64,
		::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		Vec<SetParam>,
	) {
		(id, author_id, created_at, _params)
	}
	#[macro_export]
	macro_rules ! _select_video { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: video :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: video :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: video :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: video :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: video :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: video :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , author_id , author , comments , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: video :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: video :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: video :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: video :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: video :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: video :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "authorId" , "author" , "comments" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: video :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; author_id) => { i64 } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: user :: Data } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Video" , available fields are "id, author_id, author, comments, created_at")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: id :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: author_id :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: author :: Select :: $ selection_mode ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: comments :: Select :: $ selection_mode ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: comments :: Select :: Fetch ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: video :: SelectParam > :: into ($ crate :: prisma :: video :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: video :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "authorId" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _select_video as select;
	pub enum SelectParam {
		Id(id::Select),
		AuthorId(author_id::Select),
		Author(author::Select),
		Comments(comments::Select),
		CreatedAt(created_at::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::AuthorId(data) => data.to_selection(),
				Self::Author(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_video { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: video :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: video :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: video :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: video :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: video :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: video :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author , comments } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub author_id : i64 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: video :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (author_id) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; author_id) , & self . author_id) ? ; state . serialize_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , author_id , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: video :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: video :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: video :: include ! (@ field_serde_name ; author_id) , ", " , $ crate :: prisma :: video :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: video :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: video :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: video :: include ! (@ field_serde_name ; author_id) => Ok (Field :: author_id) , $ crate :: prisma :: video :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut author_id = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; author_id))) ; } author_id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; id))) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; author_id))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: video :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { id , author_id , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "authorId" , "author" , "comments" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: video :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: user :: Data } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Video" , available relations are "author, comments")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: video :: IncludeParam > :: into ($ crate :: prisma :: video :: author :: Include :: $ selection_mode ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: video :: IncludeParam > :: into ($ crate :: prisma :: video :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: video :: IncludeParam > :: into ($ crate :: prisma :: video :: comments :: Include :: $ selection_mode ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: video :: IncludeParam > :: into ($ crate :: prisma :: video :: comments :: Include :: Fetch ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: video :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "authorId" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _include_video as include;
	pub enum IncludeParam {
		Id(id::Include),
		AuthorId(author_id::Include),
		Author(author::Include),
		Comments(comments::Include),
		CreatedAt(created_at::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::AuthorId(data) => data.to_selection(),
				Self::Author(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i64,
		#[serde(rename = "authorId")]
		pub author_id: i64,
		#[serde(rename = "author")]
		pub author: Option<Box<super::user::Data>>,
		#[serde(rename = "comments")]
		pub comments: Option<Vec<super::comment::Data>>,
		#[serde(rename = "createdAt")]
		pub created_at:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
	}
	impl Data {
		pub fn author(
			&self,
		) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.author
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(author),
				))
				.map(|v| v.as_ref())
		}
		pub fn comments(
			&self,
		) -> Result<&Vec<super::comment::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.comments
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(comments),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Author(super::user::UniqueArgs),
		Comments(super::comment::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Author(args) => {
					let mut selections = < super :: user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("author");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Comments(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("comments");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i64),
		IncrementId(i64),
		DecrementId(i64),
		MultiplyId(i64),
		DivideId(i64),
		SetAuthorId(i64),
		IncrementAuthorId(i64),
		DecrementAuthorId(i64),
		MultiplyAuthorId(i64),
		DivideAuthorId(i64),
		ConnectAuthor(super::user::UniqueWhereParam),
		ConnectComments(Vec<super::comment::UniqueWhereParam>),
		DisconnectComments(Vec<super::comment::UniqueWhereParam>),
		SetComments(Vec<super::comment::UniqueWhereParam>),
		SetCreatedAt(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::SetAuthorId(value) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				),
				SetParam::IncrementAuthorId(value) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DecrementAuthorId(value) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::MultiplyAuthorId(value) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DivideAuthorId(value) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::ConnectAuthor(where_param) => (
					"author".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::user::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::ConnectComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetCreatedAt(value) => (
					"createdAt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		AuthorId(::prisma_client_rust::Direction),
		CreatedAt(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::AuthorId(direction) => (
					"authorId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::CreatedAt(direction) => (
					"createdAt".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i64),
		Id(_prisma::read_filters::BigIntFilter),
		AuthorIdEquals(i64),
		AuthorId(_prisma::read_filters::BigIntFilter),
		AuthorIs(Vec<super::user::WhereParam>),
		AuthorIsNot(Vec<super::user::WhereParam>),
		CommentsSome(Vec<super::comment::WhereParam>),
		CommentsEvery(Vec<super::comment::WhereParam>),
		CommentsNone(Vec<super::comment::WhereParam>),
		CreatedAtEquals(
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		),
		CreatedAt(_prisma::read_filters::DateTimeFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::AuthorIdEquals(value) => (
					"authorId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				Self::AuthorId(value) => ("authorId", value.into()),
				Self::AuthorIs(where_params) => (
					"author",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::AuthorIsNot(where_params) => (
					"author",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsSome(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsEvery(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsNone(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CreatedAtEquals(value) => (
					"createdAt",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				),
				Self::CreatedAt(value) => ("createdAt", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i64),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Video";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "authorId", "createdAt"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			id: i64,
			author: super::user::UniqueWhereParam,
			created_at: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(id::set(id));
			_params.push(author::connect(author));
			_params.push(created_at::set(created_at));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(
				i64,
				i64,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				Vec<SetParam>,
			)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(id, author_id, created_at, mut _params)| {
					_params.push(id::set(id));
					_params.push(author_id::set(author_id));
					_params.push(created_at::set(created_at));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(id, author, created_at, mut _params): (
				i64,
				super::user::UniqueWhereParam,
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(id::set(id));
			_params.push(author::connect(author));
			_params.push(created_at::set(created_at));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod user {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::NotInVec(value))
		}
		pub fn lt(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Lt(value))
		}
		pub fn lte(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Lte(value))
		}
		pub fn gt(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Gt(value))
		}
		pub fn gte(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Gte(value))
		}
		pub fn not(value: i64) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BigIntFilter::Not(value))
		}
		pub fn increment(value: i64) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i64) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i64) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i64) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i64);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod username {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::UsernameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Username(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn mode(value: QueryMode) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Mode(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Username(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUsername(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Username(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("username").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Username(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("username").build()
			}
		}
	}
	pub mod comments {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsSome(value)
		}
		pub fn every(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsEvery(value)
		}
		pub fn none(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsNone(value)
		}
		pub struct Fetch(pub comment::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<comment::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: comment::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: comment::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Comments(fetch.0)
			}
		}
		pub fn fetch(params: Vec<comment::WhereParam>) -> Fetch {
			Fetch(comment::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<comment::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectComments(params)
		}
		pub fn set(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::SetComments(params)
		}
		pub struct Connect(pub Vec<comment::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectComments(value.0)
			}
		}
		pub enum Include {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Comments(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Comments(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("comments");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod videos {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<video::WhereParam>) -> WhereParam {
			WhereParam::VideosSome(value)
		}
		pub fn every(value: Vec<video::WhereParam>) -> WhereParam {
			WhereParam::VideosEvery(value)
		}
		pub fn none(value: Vec<video::WhereParam>) -> WhereParam {
			WhereParam::VideosNone(value)
		}
		pub struct Fetch(pub video::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<video::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: video::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: video::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Videos(fetch.0)
			}
		}
		pub fn fetch(params: Vec<video::WhereParam>) -> Fetch {
			Fetch(video::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<video::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<video::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectVideos(params)
		}
		pub fn set(params: Vec<video::UniqueWhereParam>) -> SetParam {
			SetParam::SetVideos(params)
		}
		pub struct Connect(pub Vec<video::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectVideos(value.0)
			}
		}
		pub enum Include {
			Select(video::ManyArgs, Vec<video::SelectParam>),
			Include(video::ManyArgs, Vec<video::IncludeParam>),
			Fetch(video::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Videos(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("videos");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: video::ManyArgs,
				nested_selections: Vec<video::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: video::ManyArgs,
				nested_selections: Vec<video::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(video::ManyArgs, Vec<video::SelectParam>),
			Include(video::ManyArgs, Vec<video::IncludeParam>),
			Fetch(video::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Videos(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("videos");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: video::ManyArgs,
				nested_selections: Vec<video::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: video::ManyArgs,
				nested_selections: Vec<video::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod created_at {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAtEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::CreatedAt(direction)
		}
		pub fn in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
		}
		pub fn not_in_vec(
			value: Vec<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
		}
		pub fn lt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
		}
		pub fn lte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
		}
		pub fn gt(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
		}
		pub fn gte(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
		}
		pub fn not(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCreatedAt(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CreatedAt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CreatedAt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("createdAt").build()
			}
		}
	}
	pub fn create(
		id: i64,
		username: String,
		_params: Vec<SetParam>,
	) -> (i64, String, Vec<SetParam>) {
		(id, username, _params)
	}
	pub fn create_unchecked(
		id: i64,
		username: String,
		_params: Vec<SetParam>,
	) -> (i64, String, Vec<SetParam>) {
		(id, username, _params)
	}
	#[macro_export]
	macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , username , comments , videos , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username" , "comments" , "videos" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; username) => { String } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; videos : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < videos :: Data > } ; (@ field_type ; videos) => { Vec < crate :: prisma :: video :: Data > } ; (@ field_type ; created_at) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, username, comments, videos, created_at")) } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; videos : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: video :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: username :: Select) } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: comments :: Select :: $ selection_mode ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: comments :: Select :: Fetch ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; videos $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: videos :: Select :: $ selection_mode ($ crate :: prisma :: video :: ManyArgs :: new ($ crate :: prisma :: video :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: video :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; videos $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: videos :: Select :: Fetch ($ crate :: prisma :: video :: ManyArgs :: new ($ crate :: prisma :: video :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; videos) => { "videos" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _select_user as select;
	pub enum SelectParam {
		Id(id::Select),
		Username(username::Select),
		Comments(comments::Select),
		Videos(videos::Select),
		CreatedAt(created_at::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Username(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::Videos(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: user :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { comments , videos } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub username : String , pub created_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (username) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , & self . username) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , username , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) => Ok (Field :: username) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut username = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ; } username = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { id , username , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username" , "comments" , "videos" , "createdAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; videos : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < videos :: Data > } ; (@ field_type ; videos) => { Vec < crate :: prisma :: video :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "comments, videos")) } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: comment :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; videos : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: video :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: comments :: Include :: $ selection_mode ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: comment :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: comments :: Include :: Fetch ($ crate :: prisma :: comment :: ManyArgs :: new ($ crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; videos $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: videos :: Include :: $ selection_mode ($ crate :: prisma :: video :: ManyArgs :: new ($ crate :: prisma :: video :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: video :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; videos $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: videos :: Include :: Fetch ($ crate :: prisma :: video :: ManyArgs :: new ($ crate :: prisma :: video :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; videos) => { "videos" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; }
	pub use _include_user as include;
	pub enum IncludeParam {
		Id(id::Include),
		Username(username::Include),
		Comments(comments::Include),
		Videos(videos::Include),
		CreatedAt(created_at::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Username(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::Videos(data) => data.to_selection(),
				Self::CreatedAt(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i64,
		#[serde(rename = "username")]
		pub username: String,
		#[serde(rename = "comments")]
		pub comments: Option<Vec<super::comment::Data>>,
		#[serde(rename = "videos")]
		pub videos: Option<Vec<super::video::Data>>,
		#[serde(rename = "createdAt")]
		pub created_at: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
	}
	impl Data {
		pub fn comments(
			&self,
		) -> Result<&Vec<super::comment::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.comments
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(comments),
				))
		}
		pub fn videos(
			&self,
		) -> Result<&Vec<super::video::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.videos
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(videos),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Comments(super::comment::ManyArgs),
		Videos(super::video::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Comments(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: comment :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("comments");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::Videos(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: video :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("videos");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i64),
		IncrementId(i64),
		DecrementId(i64),
		MultiplyId(i64),
		DivideId(i64),
		SetUsername(String),
		ConnectComments(Vec<super::comment::UniqueWhereParam>),
		DisconnectComments(Vec<super::comment::UniqueWhereParam>),
		SetComments(Vec<super::comment::UniqueWhereParam>),
		ConnectVideos(Vec<super::video::UniqueWhereParam>),
		DisconnectVideos(Vec<super::video::UniqueWhereParam>),
		SetVideos(Vec<super::video::UniqueWhereParam>),
		SetCreatedAt(
			Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				SetParam::SetUsername(value) => (
					"username".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetComments(where_params) => (
					"comments".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::ConnectVideos(where_params) => (
					"videos".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::video::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectVideos(where_params) => (
					"videos".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::video::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetVideos(where_params) => (
					"videos".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::video::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetCreatedAt(value) => (
					"createdAt".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Username(::prisma_client_rust::Direction),
		CreatedAt(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Username(direction) => (
					"username".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::CreatedAt(direction) => (
					"createdAt".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i64),
		Id(_prisma::read_filters::BigIntFilter),
		UsernameEquals(String),
		Username(_prisma::read_filters::StringFilter),
		CommentsSome(Vec<super::comment::WhereParam>),
		CommentsEvery(Vec<super::comment::WhereParam>),
		CommentsNone(Vec<super::comment::WhereParam>),
		VideosSome(Vec<super::video::WhereParam>),
		VideosEvery(Vec<super::video::WhereParam>),
		VideosNone(Vec<super::video::WhereParam>),
		CreatedAtEquals(
			Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		),
		CreatedAt(_prisma::read_filters::DateTimeFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::UsernameEquals(value) => (
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Username(value) => ("username", value.into()),
				Self::CommentsSome(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsEvery(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsNone(where_params) => (
					"comments",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::VideosSome(where_params) => (
					"videos",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::VideosEvery(where_params) => (
					"videos",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::VideosNone(where_params) => (
					"videos",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CreatedAtEquals(value) => (
					"createdAt",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::CreatedAt(value) => ("createdAt", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i64),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "User";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "username", "createdAt"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(self, id: i64, username: String, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(id::set(id));
			_params.push(username::set(username));
			Create::new(self.client, _params)
		}
		pub fn create_many(self, data: Vec<(i64, String, Vec<SetParam>)>) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(id, username, mut _params)| {
					_params.push(id::set(id));
					_params.push(username::set(username));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(id, username, mut _params): (i64, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(id::set(id));
			_params.push(username::set(username));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		pub fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let config =
				::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
			let source = config
				.datasources
				.first()
				.expect("Please supply a datasource in your schema.prisma file");
			let url = match self.url {
				Some(url) => url,
				None => {
					let url = if let Some(url) = source.load_shadow_database_url()? {
						url
					} else {
						source.load_url(|key| std::env::var(key).ok())?
					};
					match url.starts_with("file:") {
						true => {
							let path = url.split(":").nth(1).unwrap();
							if std::path::Path::new("./prisma/schema.prisma").exists() {
								format!("file:./prisma/{}", path)
							} else {
								url
							}
						}
						_ => url,
					}
				}
			};
			let (db_name, executor) =
				::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
			let internal_model =
				::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
					super::DATAMODEL_STR,
				)
				.build(db_name);
			let query_schema =
				std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
					internal_model,
					true,
					source.capabilities(),
					vec![],
					source.referential_integrity(),
				));
			executor.primary_connector().get_connection().await?;
			Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals {
				executor,
				query_schema,
				url,
				action_notifier: self.action_notifier,
			}))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub fn comment_fragment(&self) -> super::comment_fragment::Actions {
			super::comment_fragment::Actions { client: &self.0 }
		}
		pub fn comment(&self) -> super::comment::Actions {
			super::comment::Actions { client: &self.0 }
		}
		pub fn video(&self) -> super::video::Actions {
			super::video::Actions { client: &self.0 }
		}
		pub fn user(&self) -> super::user::Actions {
			super::user::Actions { client: &self.0 }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum CommentFragmentScalarFieldEnum {
		#[serde(rename = "index")]
		Index,
		#[serde(rename = "commentId")]
		CommentId,
		#[serde(rename = "text")]
		Text,
		#[serde(rename = "emote")]
		Emote,
	}
	impl ToString for CommentFragmentScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Index => "index".to_string(),
				Self::CommentId => "commentId".to_string(),
				Self::Text => "text".to_string(),
				Self::Emote => "emote".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum CommentScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "userId")]
		UserId,
		#[serde(rename = "videoId")]
		VideoId,
		#[serde(rename = "createdAt")]
		CreatedAt,
	}
	impl ToString for CommentScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::UserId => "userId".to_string(),
				Self::VideoId => "videoId".to_string(),
				Self::CreatedAt => "createdAt".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum QueryMode {
		#[serde(rename = "default")]
		Default,
		#[serde(rename = "insensitive")]
		Insensitive,
	}
	impl ToString for QueryMode {
		fn to_string(&self) -> String {
			match self {
				Self::Default => "default".to_string(),
				Self::Insensitive => "insensitive".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "ReadUncommitted")]
		ReadUncommitted,
		#[serde(rename = "ReadCommitted")]
		ReadCommitted,
		#[serde(rename = "RepeatableRead")]
		RepeatableRead,
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::ReadUncommitted => "ReadUncommitted".to_string(),
				Self::ReadCommitted => "ReadCommitted".to_string(),
				Self::RepeatableRead => "RepeatableRead".to_string(),
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum UserScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "username")]
		Username,
		#[serde(rename = "createdAt")]
		CreatedAt,
	}
	impl ToString for UserScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Username => "username".to_string(),
				Self::CreatedAt => "createdAt".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum VideoScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "authorId")]
		AuthorId,
		#[serde(rename = "createdAt")]
		CreatedAt,
	}
	impl ToString for VideoScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::AuthorId => "authorId".to_string(),
				Self::CreatedAt => "createdAt".to_string(),
			}
		}
	}
	pub mod read_filters {
		use super::*;
		#[derive(Clone)]
		pub enum IntFilter {
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(i32),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum StringFilter {
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Mode(QueryMode),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Mode(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"mode".to_string(),
							::prisma_client_rust::PrismaValue::Enum(value.to_string()),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BigIntFilter {
			InVec(Vec<i64>),
			NotInVec(Vec<i64>),
			Lt(i64),
			Lte(i64),
			Gt(i64),
			Gte(i64),
			Not(i64),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeFilter {
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				}
			}
		}
	}
}
pub use _prisma::PrismaClient;
